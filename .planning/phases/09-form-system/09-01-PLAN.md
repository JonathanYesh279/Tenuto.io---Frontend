---
phase: 09-form-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/ui/form-field.tsx
  - src/components/OrchestraForm.tsx
autonomous: true

must_haves:
  truths:
    - "FormField wrapper renders a visible label above any input slot, a red error message below when error prop is set, and wires htmlFor/id for accessibility"
    - "OrchestraForm uses FormField wrapper for every field — visible labels stay visible regardless of input value"
    - "OrchestraForm uses shadcn Select (Radix) instead of native <select> for all 5 dropdowns"
    - "OrchestraForm uses shadcn Input instead of native <input> for text fields"
    - "OrchestraForm uses shadcn Checkbox instead of native <input type=checkbox>"
    - "OrchestraForm shows inline red border + error message under the specific field that fails validation"
    - "OrchestraForm buttons follow consistent pattern: Cancel first in DOM, Save second, with flex justify-end gap-3"
  artifacts:
    - path: "src/components/ui/form-field.tsx"
      provides: "Shared FormField wrapper (Label + input slot + error message)"
      exports: ["FormField"]
    - path: "src/components/OrchestraForm.tsx"
      provides: "Orchestra create/edit form with shadcn primitives"
  key_links:
    - from: "src/components/ui/form-field.tsx"
      to: "src/components/ui/label.tsx"
      via: "import { Label }"
      pattern: "import.*Label.*from.*label"
    - from: "src/components/OrchestraForm.tsx"
      to: "src/components/ui/form-field.tsx"
      via: "import { FormField }"
      pattern: "import.*FormField.*from.*form-field"
    - from: "src/components/OrchestraForm.tsx"
      to: "src/components/ui/select.tsx"
      via: "import { Select, SelectTrigger, ... }"
      pattern: "import.*Select.*from.*ui/select"
---

<objective>
Create the shared FormField wrapper component and migrate OrchestraForm as the first form to use consistent shadcn/ui-styled inputs.

Purpose: FormField is the keystone component for Phase 9 — it provides Label + input slot + error message with consistent styling, accessibility wiring (htmlFor/id), and RTL-correct layout. OrchestraForm (417 lines, simplest form) validates the pattern before applying it to the larger forms.

Output: FormField component in ui/, OrchestraForm fully migrated to shadcn primitives with inline validation.
</objective>

<execution_context>
@/home/yona279/.claude/get-shit-done/workflows/execute-plan.md
@/home/yona279/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-form-system/09-RESEARCH.md

@src/components/ui/label.tsx
@src/components/ui/input.tsx
@src/components/ui/select.tsx
@src/components/ui/checkbox.tsx
@src/components/ui/textarea.tsx
@src/components/ui/separator.tsx
@src/components/OrchestraForm.tsx
@src/utils/orchestraUtils.ts
@src/constants/enums.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FormField wrapper component and migrate OrchestraForm to shadcn primitives</name>
  <files>
    src/components/ui/form-field.tsx
    src/components/OrchestraForm.tsx
  </files>
  <action>
**Part A: Create FormField wrapper (src/components/ui/form-field.tsx)**

Create a new FormField component that wraps Label + input slot + error message. Follow the exact pattern from 09-RESEARCH.md Pattern 1:

```typescript
import * as React from "react"
import { AlertCircle } from "lucide-react"
import { Label } from "@/components/ui/label"
import { cn } from "@/lib/utils"

interface FormFieldProps {
  label: string
  htmlFor: string
  error?: string
  required?: boolean
  hint?: string
  className?: string
  children: React.ReactNode
}

export function FormField({ label, htmlFor, error, required, hint, className, children }: FormFieldProps) {
  return (
    <div className={cn("space-y-1.5", className)}>
      <Label htmlFor={htmlFor}>
        {label}
        {required && <span className="text-destructive ms-1" aria-hidden="true">*</span>}
      </Label>
      {children}
      {error && (
        <p id={`${htmlFor}-error`} role="alert" className="flex items-center gap-1 text-sm text-destructive">
          <AlertCircle className="h-3.5 w-3.5 shrink-0" aria-hidden="true" />
          {error}
        </p>
      )}
      {hint && !error && (
        <p className="text-xs text-muted-foreground">{hint}</p>
      )}
    </div>
  )
}
```

**Part B: Migrate OrchestraForm.tsx to shadcn primitives**

Replace all form elements in OrchestraForm.tsx:

1. **Replace all 5 native `<select>` elements** with shadcn Select (Radix):
   - Type select (formData.type) — simple list from VALID_ORCHESTRA_TYPES
   - Sub-type select (formData.subType) — from ORCHESTRA_SUBTYPES
   - Performance level select (formData.performanceLevel) — from PERFORMANCE_LEVELS
   - Location select (formData.location) — grouped by category (see below)
   - Conductor select (formData.conductorId) — from filtered teachers list

   Pattern for simple flat selects (type, subType, performanceLevel, conductor):
   ```tsx
   <FormField label="סוג הרכב" htmlFor="type" error={errors.type} required>
     <Select value={formData.type} onValueChange={(val) => handleInputChange('type', val)}>
       <SelectTrigger id="type" className={cn(errors.type && "border-destructive focus:ring-destructive")}>
         <SelectValue placeholder="בחר סוג" />
       </SelectTrigger>
       <SelectContent>
         {VALID_ORCHESTRA_TYPES.map(type => (
           <SelectItem key={type} value={type}>{type}</SelectItem>
         ))}
       </SelectContent>
     </Select>
   </FormField>
   ```

   **CRITICAL for location select — grouped optgroups:** The existing location select groups locations into 6 `<optgroup>` categories using `.filter()` predicates. Replicate this with `SelectGroup`/`SelectLabel`. The groups and their filter predicates (matching the existing pattern in OrchestraForm.tsx lines 198-241) are:
   - "אולמות": `loc.includes('אולם')`
   - "סטודיואים": `loc.includes('סטודיו')`
   - "חדרי חזרות": `loc.includes('חדר חזרות')`
   - "חדרי לימוד": `loc.startsWith('חדר') && !loc.includes('חזרות') && !loc.includes('תאוריה')`
   - "חדרי תיאוריה": `loc.includes('תאוריה')`
   - "אחר": `!loc.includes('אולם') && !loc.includes('סטודיו') && !loc.includes('חדר')`

   ```tsx
   <FormField label="מיקום" htmlFor="location" error={errors.location} required>
     <Select value={formData.location} onValueChange={(val) => handleInputChange('location', val as LocationType)}>
       <SelectTrigger id="location" className={cn(errors.location && "border-destructive focus:ring-destructive")}>
         <SelectValue placeholder="בחר מיקום" />
       </SelectTrigger>
       <SelectContent>
         <SelectGroup>
           <SelectLabel>אולמות</SelectLabel>
           {VALID_LOCATIONS.filter(loc => loc.includes('אולם')).map(location => (
             <SelectItem key={location} value={location}>{location}</SelectItem>
           ))}
         </SelectGroup>
         <SelectGroup>
           <SelectLabel>סטודיואים</SelectLabel>
           {VALID_LOCATIONS.filter(loc => loc.includes('סטודיו')).map(location => (
             <SelectItem key={location} value={location}>{location}</SelectItem>
           ))}
         </SelectGroup>
         <SelectGroup>
           <SelectLabel>חדרי חזרות</SelectLabel>
           {VALID_LOCATIONS.filter(loc => loc.includes('חדר חזרות')).map(location => (
             <SelectItem key={location} value={location}>{location}</SelectItem>
           ))}
         </SelectGroup>
         <SelectGroup>
           <SelectLabel>חדרי לימוד</SelectLabel>
           {VALID_LOCATIONS.filter(loc => loc.startsWith('חדר') && !loc.includes('חזרות') && !loc.includes('תאוריה')).map(location => (
             <SelectItem key={location} value={location}>{location}</SelectItem>
           ))}
         </SelectGroup>
         <SelectGroup>
           <SelectLabel>חדרי תיאוריה</SelectLabel>
           {VALID_LOCATIONS.filter(loc => loc.includes('תאוריה')).map(location => (
             <SelectItem key={location} value={location}>{location}</SelectItem>
           ))}
         </SelectGroup>
         <SelectGroup>
           <SelectLabel>אחר</SelectLabel>
           {VALID_LOCATIONS.filter(loc => !loc.includes('אולם') && !loc.includes('סטודיו') && !loc.includes('חדר')).map(location => (
             <SelectItem key={location} value={location}>{location}</SelectItem>
           ))}
         </SelectGroup>
       </SelectContent>
     </Select>
   </FormField>
   ```

   Import `SelectGroup` and `SelectLabel` along with other Select subcomponents.

   **CRITICAL for conductor select:** The conductor select has an empty/default "בחר מנצח" option. Radix Select does NOT support an empty string value. Use a placeholder on SelectValue instead. If current value is empty string, do NOT pass value="" to Select — pass value={undefined} or use the `placeholder` prop on SelectValue.

2. **Replace all native `<input type="text">` elements** with shadcn Input:
   - Orchestra name input
   - Coordination hours number input

   Pattern:
   ```tsx
   <FormField label="שם התזמורת" htmlFor="name" error={errors.name} required>
     <Input
       id="name"
       value={formData.name}
       onChange={(e) => handleInputChange('name', e.target.value)}
       aria-invalid={!!errors.name}
       aria-describedby={errors.name ? 'name-error' : undefined}
       className={cn(errors.name && "border-destructive focus-visible:ring-destructive")}
       placeholder="הזן שם לתזמורת"
     />
   </FormField>
   ```

3. **Replace native `<input type="checkbox">` for isActive** with shadcn Checkbox:
   ```tsx
   <div className="flex items-center gap-2">
     <Checkbox
       id="isActive"
       checked={formData.isActive}
       onCheckedChange={(checked) => handleInputChange('isActive', checked as boolean)}
     />
     <Label htmlFor="isActive">תזמורת פעילה</Label>
   </div>
   <p className="text-xs text-muted-foreground mt-1">תזמורות לא פעילות לא יוצגו ברשימות הראשיות</p>
   ```

4. **Wrap the form header section** with a consistent section heading pattern. The form already has a logical "Basic Information" group — add a section heading using Separator if helpful but don't over-structure a small form.

5. **Update button styling** to use shadcn Button:
   - Import `Button` from `@/components/ui/button`
   - Cancel: `<Button type="button" variant="outline" onClick={onCancel} disabled={loading}>ביטול</Button>`
   - Save: `<Button type="submit" disabled={loading}><Save className="w-4 h-4 ms-2" />{text}</Button>`
   - Keep existing `flex justify-end gap-3` container pattern (already correct for RTL)

6. **Replace hardcoded color classes** with design token equivalents:
   - `text-gray-700` → `text-foreground` or `text-muted-foreground`
   - `border-gray-200/300` → `border-border` or `border-input`
   - `bg-white` → `bg-background` or `bg-card`
   - `border-red-300` → `border-destructive`
   - `text-red-500/600/800` → `text-destructive`
   - `bg-red-50` → use destructive token with opacity or keep as-is for error banner
   - `hover:bg-gray-100/50` → `hover:bg-muted`

7. **Keep the modal wrapper as-is** (fixed inset-0 overlay). This form renders inside a raw div overlay, not a shadcn Dialog. OrchestraForm is called from Orchestras.tsx page where the overlay is managed. Don't convert the modal wrapper — that's a separate concern.

8. **Add aria-invalid and aria-describedby** to all input elements that have associated errors.

**Do NOT:**
- Migrate to React Hook Form (OrchestraForm uses useState, which is fine for a single-page form)
- Remove the existing validateOrchestraForm() import and validation logic
- Change the form submission logic or data shape
- Modify the component's prop interface (OrchestraFormProps stays the same)
  </action>
  <verify>
1. Run `npx tsc --noEmit 2>&1 | grep -E "(form-field|OrchestraForm)" | head -20` — zero TypeScript errors in these files
2. Run `grep -c '<select' src/components/OrchestraForm.tsx` — should return 0 (zero native selects remaining)
3. Run `grep -c 'FormField' src/components/OrchestraForm.tsx` — should be >= 5 (every field wrapped)
4. Run `grep -c 'border-red-300\|text-red-500\|text-red-600\|text-red-800\|bg-red-50\|text-gray-700\|border-gray-300\|border-gray-200\|bg-white\|bg-gray-100\|hover:bg-gray-50' src/components/OrchestraForm.tsx` — should be 0 or near-0 (hardcoded colors replaced with tokens)
5. Run `grep 'aria-invalid\|aria-describedby' src/components/OrchestraForm.tsx | wc -l` — should be > 0
  </verify>
  <done>
FormField wrapper component exists at src/components/ui/form-field.tsx and exports FormField. OrchestraForm uses FormField for every field, shadcn Select for all dropdowns, shadcn Input for text fields, shadcn Checkbox for isActive, shadcn Button for actions. Zero native `<select>` elements remain. Inline validation shows red border + error message under the specific field. Labels are visible and wired via htmlFor/id. Button placement follows RTL-correct flex justify-end gap-3 pattern.
  </done>
</task>

</tasks>

<verification>
1. FormField component renders label above input, error below, with htmlFor/id wiring
2. OrchestraForm has zero native `<select>` — all replaced with Radix Select
3. OrchestraForm uses design tokens (not hardcoded gray/red classes)
4. All form fields have visible labels via FormField wrapper
5. Error states show red border on input + message below via FormField
6. Buttons: Cancel (outline) then Save (primary), flex justify-end gap-3
</verification>

<success_criteria>
- `grep -c '<select' src/components/OrchestraForm.tsx` returns 0
- `grep -c 'FormField' src/components/OrchestraForm.tsx` returns >= 5
- TypeScript compiles without errors for both files
- OrchestraForm button section uses shadcn Button components
</success_criteria>

<output>
After completion, create `.planning/phases/09-form-system/09-01-SUMMARY.md`
</output>
